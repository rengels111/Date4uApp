Hierarchische Kontexte

Oft nutzt eine Spring-Boot-Anwendung nur einen ApplicationContext.
    - Jede Spring-managed Bean ist an jeder Stelle injizierbar.

Es lassen sich auch hierarchische Eltern-Kind-Beziehungen bilden.
    - Damit lassen sich die Sichtbarkeiten der Spring-managed Beans steuern und isolierte 'Module' bilden.
    - Bei einer Onion-Architecture ist das nützlich.
    - Bei einer Webanwendung möchte man vielleicht gemeinsame Applikation-Beans haben, aber sonst soll jede
    Webanwendung ihre eigenen Beans nutzen.
    - Im Kern steckt das Wichtigste, die Domäne und die ist völlig technologie-unabhängig.
    - Außen sind die Schichten, z.B. die Infrastruktur. Die äußeren Schichten dürfen die inneren Komponenten nutzen,
    aber die inneren Komponenten wissen nichts von der äußeren Infrastruktur.
    -> Sowas wird durch hierarchische Kontexte unterstützt.
    - Die inneren Komponenten bilden die Basis, also die Eltern und die äußeren Komponenten sind die Kinder.
    - Die Kind-Komponenten können somit die inneren -Eltern-Komponenten sehen, aber umgekehrt nicht.
    - Bei Webanwendungen macht dies auch Sinn, indem verschiedene Webkomponenten voneinander getrennt werden.


Wie lässt sich das realisieren?

1. Typen trennen
- Damit die Typen den Kontexten zugeordnet werden können, wird eine Klasse mit zwei Konfigurationen geschrieben.
- Es wird in ParentConfig- und ChildConfig-Klassen aufgeteilt, die jeweils eigene @ComponentScan Pfade nutzen, damit
die Beans separat voneinander gescannt werden:

package abc.hierarchy;  // Hierfür wird ein eigenes Package verwendet.

public class MainApplication {  // in dem Beispiel wurde dafür eine eigene Klasse für die Konfigurationen aufgebaut.

    // Elternkontext
    @Configuration( proxyBeanMethods = false )  // Es werden keine Proxys für die Bean-Methoden erstellt. Damit wird
    // Zugriff auf Spring-Bean-Methoden gesteuert.
    @ComponentScan( "abc.hierarchy.parent" )  // Komponenten werden nur im parent-Package gescannt.
    public static class ParentConfig { }

    //Kindkontext
    @Configuration( proxyBeanMethods = false )  // Proxys ebenso deaktiviert.
    @ComponentScan( "abc.hierarchy.child" )  // Komponenten werden nur im child-Package gescannt.
    public static class ChildConfig { }
}

2. Das Verhältnis zu Parent und Child
Simples Beispiel zur Erklärung:

package abc.hierarchy.parent;

@Component  // Diese Klasse wird über das ClasspathScanning erkannt.
public class Parent {
    // kein @Autowired!  Parent-Klasse soll keinen Zugriff auf Child-Komponenten haben!
    // Keine Referenz auf Child. Parent kennt nicht Child.
}

package abc.hierarchy.child;

@Component  // Klasse über ClasspathScanning erkannt.
public class Child {
    @Autowired Parent parent;  // Child hat Zugriff auf Parent-Komponenten.
    // Referenz auf Parent vorhanden. Child kennt Parent.
}

3. Konfiguration über SpringBootConfiguration
@SpringBootApplication lässt sich nicht mehr verwenden, denn die damit verbundene Autokonfiguration registriert alle
Beans in den Unterpaketen im Root-Kontext.

package abc.hierarchy;

// Anstatt SpringBootApplication nehmen wir die zwei Teile davon (@SpringBootConfiguration
// und @EnableAutoConfiguration) und lassen @ClasspathScanning weg, damit nicht alle Komponenten gescannt werden:
@SpringBootConfiguration
@EnableAutoConfiguration
// ClasspathScanning ist in den geschachtelten Unterklassen aktiviert.
public class MainApplication {

    ...
    static class *Config { }
    public static void main( String[] args ) { ... }
}

4. Anstatt SpringApplication, nutzen wir den SpringApplicationBuilder, mit dem sich hierarchische Kontexte bilden lassen.
Mit dem SpringApplicationBuilder haben wir 3 Methoden, die im Zusammenhang mit dem hierarchischen Kontext stehen:
- parent(Class<?>... sources): Setzt den Elternkontext. (Häufig kann man stattdessen die Methode sources anstatt parent
nutzen.)
- child(Class<?>... sources): Setzt die Kinder (Defaults werden von Eltern übernommen). Zurück kommt der neue Kontext
von Kind. -> Bei der Deklaration ist die Reihenfolge wichtig. Kaskadischer Aufbau.
- sibling(Class<?>... sources): Setzt Geschwister gleichwertig unter den Elternkontext.

5. Beispiel für hierarchischen Kontext
ChildConfig steht unter ParentConfig:

new SpringApplicationBuilder( /* ParentConfig.class */ ) // Diese Variante geht auch anstatt .parent(...)
    // .sources( ParentConfig.class )  // oder diese Variante mit .sources anstatt .parent
    .parent( ParentConfig.class )
    .child( ChildConfig.class )
//  .sibling( AnotherChildConfig.class )
    .run(args);

Zusammenfassung:
- Die Reihenfolge ist ganz wichtig. Erst .parent, dann .child und dann erst .sibling.
- Ein hierarchischer Kontext schränkt die Sichtbarkeit von Spring-managed Beans ein.
- Spring-managed Beans aus einem übergeordneten Kontext (parent) sind in einem untergeordneten Kontext (child)
zugänglich, aber nicht andersherum.
- Jeder untergeordnete Kontext hat höchstens einen übergeordneten Kontext. -> Jedes child nur ein parent.





