Konfigurationsklassen und Fabrikmethoden

Wenn Klassen mit @Component bzw. den Composed Annotations annotiert sind, werden sie durch das Classpath-Scanning
erkannt und es wird unweigerlich über den Konstruktor eine Instanz (Spring managed-Bean) erzeugt.
- Der Nachteil ist, dass man nicht je nach Situation steuern kann welche Instanzen gebaut werden sollen.

- Wir brauchen jedoch manchmal Fabrikmethoden, die die Erzeugung der Beans an bestimmte Bedingungen knüpfen.
    -> Ich bekomme die Bean A, anderenfalls die Bean B
- Wenn wir nur @Component Klassen instanziieren könnten, dann könnten wir nur diese Klassen, die unter unserer Kontrolle
sind nutzen, verknüpfen etc. Was wäre mit Klassen, die überhaupt kein @Component besitzen? Die brauchen wir vll auch.

-> Deshalb gibt es die Fabrikmethoden, die ebenfalls Beans liefern können.
- Wir haben dort die Freiheit was wir dort für Instanzen bauen und unter welchen Abhängigkeiten.
- Außerdem können wir beliebige Instanzen von beliebigen Typen bauen und diese dann problemlos als Spring managed Bean
in den Kontext setzen.


Fabrikmethoden @Configuration und @Bean
Sind Methoden mit @Bean annotiert, lassen sich eigene Exemplare von Hand ganz individuell im eigenen Code aufbauen.
Im Ergebnis sind sie gleichwertig zu den @Component-Beans; sie lassen sich injizieren und aus dem Kontext holen.

@Configuration
public class MyOwnBeanFactory {

    @Bean
    Foo bean_name_is_method_name() { return... }
    @Bean
    Bar another_factory_method() { return... }

1. Klassen mit Fabrikmethoden sind im Allgemeinen mit @Configuration annotiert.
2. Spring betrachtet alle mit @Bean annotierten Methoden als Fabrikmethoden für Spring-managed Beans.
3. Die Sichtbarkeit muss nicht public sein, Paketsichtbarkeit ist in Ordnung.
4. Der Rückgabetyp sollte immer so präzise wie möglich sein.
5. Der Methodenname bestimmt den Namen der Bean. (Achtung, es darf nicht zwei Beans mit dem gleichen Namen haben)

-> Der Container ruft das Classpath-Scanning auf, findet die @Bean Methoden und ruft diese Methoden automatisch auf.
Im inneren der Methoden wird eine Instanz aufgebaut und zurückgegeben. -> Die zurückgegebene Instanz kommt dann als
Spring-managed Bean in den Kontext.

- Beim @Autowired werden die von der Fabrikmethode erzeugten @Beans gleichwertig zu den Beans behandelt, die mit
@Component annotiert wurden.

- Statische geschachtelte Klassen können ebenfalls eine @Configuration sein.
- Auch @Component-Klassen können @Bean-Methoden haben; es entsteht jedoch eine leistungsschwächere 'lite bean'.
- SpringBootApplication ist ebenfalls eine Configuration: @SpringBootConfiguration und eine @Configuration ist ebenfalls
eine @Component und somit ist dies auch ein Bean.
-> D.h. dass man in die SpringBootApplication-Klasse ebenfalls @Bean Methoden setzen kann.


Beispiel mit eigenem PromptProvider:

@Configuration
public class PromptProviderConfig {
    // PromptProvider für normale Benutzer:
    private static final PromptProvider userPromptProvider = () ->
        new AttributedString( "date4u:>" );

    // PromptProvider für Admins:
    private static final PromptProvider adminPromptProvider = () ->
        new AttributedString( "date4u[admin]:>",
            AttributedStyle.DEFAULT.foreground( AttributedStyle.RED ) );  // mit roter Schriftfarbe

    @Bean
    PromptProvider myPromptProvider() {
    if ( is admin )
        return adminPromptProvider;
    else
        return userPromptProvider;
    }
    /* Abhängig davon welche Bedingung zutrifft, wird der entsprechende PromptProvider während der Laufzeit
    instanziiert.
    */
}


Diverse Bean-Typen sind erlaubt
- Intuitiv denkt man, dass nur komplexe Objekte wie Services als Spring-managed Beans verwaltet werden können.
- Doch es lassen sich alle möglichen Objekte in den Kontext setzen, auch einfache Objekte wie z.B. Strings:

@Bean String name() {
    return "fillmore";
}

// oder Arrays:
@Bean String[] names() {
    return new String[] { "fillmore", "juicylucy" };
}

// oder Lists:
@Bean List<String> namesList() {
    return List.of( "fillmore", "juicylucy" );
}


- Fabrikmethoden können sich ebenfalls Referenzen auf andere Beans wünschen.
- Bean Methoden sind Singletons, denn sie werden nur ein einziges Mal beim Aufbau instanziiert.


InjectionPoint
- Bei der Erzeugung von Spring-managed Beans über Fabrikmethoden könnte der angeforderte Injektionspunkt (d.h. der Ort,
an dem eine Abhängigkeit in einen Spring-Bean injiziert wird) ein wichtiges Kriterium für die Konfiguration der Bean
sein.
- Eine Fabrikmethode kann einen Parameter vom Typ InjectionPoint deklarieren und so auf den Injektionspunkt zugreifen.
- Es könnte z.B. sein, dass diese Bean aus der Klasse A eingefordert wird und auch aus der Klasse B. Somit kann es sein,
dass sie dafür jeweils etwas anders konfiguriert werden muss.
- InjectionPoint wird normalerweise in fortgeschritteneren Spring-Anwendungen und in Fällen verwendet, in denen Sie
Metadaten oder spezielle Logik für die Abhängigkeitsinjektion benötigen. In den meisten Spring-Anwendungen werden Sie
wahrscheinlich @Autowired oder andere Injektions-Annotationen verwenden, ohne sich direkt auf InjectionPoint beziehen
zu müssen.
- Da eine Bean eine Singleton ist, wir jedoch vielleicht unterschiedliche Konfigurationen der Bean benötigen, je nachdem
welche Bedingung zutrifft, so kann neben @Bean die Annotation @Scope gesetzt werden:
@Bean @Scope( ConfigurableBeanFactory.SCOPE_PROTOTYPE )
Dabei werden Prototyp Beans erstellt, die immer neu erzeugt werden.


Statische @Bean-Methode
- Vorteil von statischen @Bean-Methoden ist, dass keine Instanz der Configuration Klasse existieren muss.
- Sie werden zeitlich sogar vor der umgebenden @Configuration-Bean aufgebaut.
- Statische Methoden sind nicht dynamisch gebunden, daher funktioniert der Methodenaufruf untereinander nicht so, wie
bei einer Objektmethode in einer @Configuration.
- Statische Bean-Methoden sind nur selten nötig.


Zusammenfassend:
Es gibt verschiedene Möglichkeiten, wie Spring-managed Beans aufgebaut werden können:
1. Mit Komponenten: @Component (@Controller, @Service, @Repository...)
2. Mit Fabrikmethoden: @Bean-Methoden

-> Letztendlich landen diese Komponenten in einem Sack mit allen managed Beans
-> Dann können diese managed Beans per @Autowired initiiert werden.

