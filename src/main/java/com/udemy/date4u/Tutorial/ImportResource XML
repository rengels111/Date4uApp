Import von XML-Konfigurationen mit @ImportResource

- Früher musste man die Bean Definitionen und die Verdrahtung in XML vornehmen.
- Das ist immer noch möglich, auch wenn es heutzutage eine immer geringere Rolle spielt.

Beispiel Aufgabe:
Wir wollen eine erweiterbare Software schreiben, wo unsere Kunden eigene Thumbnail Implementierung bereitstellen können.
Die Deklaration des Thumbnails soll deklarativ erfolgen und die Komponente, die der Kunde schreibt, soll völlig losgelöst
vom Spring Framework und auch ohne die Annotationen auskommen:

package com.example;

import ...

public class EmptyThumbnail implements Thumbnail {
    private static final byte[] MINIMAL_JPG = Base64.getDecoder().decode(...)
    @Override public byte[] thumbnail( byte[] imageBytes ) {
        return MINIMAL_JPG;
    }
}


Diese Implementierung soll nun angemeldet werden und als Spring-managed Bean aufgenommen werden:
Wir legen eine XML-Datei im Klassenpfad an:
src/main/resources/spring-context.xml (Datei kann beliebigen Namen haben)

In dieser Datei soll nun die Bean aufgeführt sein.

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="..........."  // diese Teile sind nicht essentiell, haben jedoch sinnvolle Funktionen.
       xmlns:xsi="......"   // z.B. Namensräume und Schema-Definitionen...
       xsi:schemaLocation="......"

   // Wichtig:
   <bean id="emptyThumbnail"  // Name der Komponente
         class="com.example.EmptyThumbnail"  // Welcher Typ steckt dahinter
         primary="true">  // Ausdruck, dass Bean Priorität hat (@Primary)
   </bean>
</beans>

Im nächsten Schritt können wir die erstellte XML-Konfiguration in unser Spring Boot Projekt importieren:
Beispiel @SpringBootApplication:

@SpringBootApplication
@ImportResource( "classpath*:spring-context.xml" )  // * bedeutet ein Array von Dateien, das kann auch leer sein.
// damit bleibt der Import Optional, falls die Datei nicht existieren sollte.
public class Date4uApplication { ... }

- die @ImportResource lässt sich an jede beliebige Configuration dransetzen.
- dies waren die Schritte, die nötig sind, um Java Beans in XML beschreiben zu können.


Es gibt jedoch noch einfachere, schlankere Alternativen Beans zu beschreiben, als per XML und zwar mit Groovy:
- Groovy ist eine alternative Programmiersprache auf der JVM, die es seit 2003 gibt.
- Bean-Konfigurationen können auch als Groovy-Skripte geschrieben werden.
- Bei Gradle werden automatisch Groovy-Skripte verwendet.

1. Einbinden der Groovy-Laufzeitumgebung, damit der Groovy Compiler uns die Laufzeitbibliotheken zur Verfügung stellt:
<dependency>
    <groupId>org.codehaus.groovy</groupId>
    <artifactId>groovy</artifactId>
</dependency>

2. Beans im Groovy-Skript deklarieren:
beans {
    emptyThumbnail(com.example.EmptyThumbnail) {
    bean -> bean.primary = true  // wie wir sehen ist dies eine deutlich einfachere Schreibweise als in XML
    }
}

3. Groovy-Skript einbinden:
@ImportResource( "classpath*:spring-context.groovy" )


- heute spielen Konfigurationen über XML praktisch keine Rolle mehr, jedoch werden sie weiterhin von Spring unterstützt.
- Nachteil bei nativer Compilation, XML muss geparst werden.
- Falls sich Klassen ändern, dann funktioniert das Ganze nicht mehr, also heutzutage nicht so praktisch.

