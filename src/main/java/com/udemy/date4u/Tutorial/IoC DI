Inversion of Control (IoC) / Dependency Injection (DI)
IoC:
- Objekte kennen sich nicht mehr selbst und haben keine Kontrolle über ihre Verkettung, sondern überlassen die
Verantwortung einer anderen Instanz.
- Das ist der IoC-Container.
DI:
- Dependency Injection ist eine besondere Form von IoC.
- Der Begriff geht auf einen Artikel von Martin Fowler im Jahr 2004 zurück.
- Es handelt sich dabei um eine Technik, bei der die Abhängigkeiten eines Objekts (wie andere Klassen oder Dienste)
nicht in der Klasse selbst erstellt, sondern von außen in die Klasse injiziert werden.
- Dies ermöglicht eine lose Kopplung zwischen verschiedenen Komponenten in einer Anwendung und erleichtert die
Wartbarkeit und Testbarkeit des Codes.


Es gibt drei Varianten von Dependency Injection:

//- Constructor Injection:
public class FsCommands {

    //Da wir DI anwenden, klammern wir das nun aus:
    // private final FileSystem fs = new FileSystem();

    //Und nun wird FileSystem mit Constructor Injection erzeugt:

    //Wir erzeugen erst eine Variable:
    private final FileSystem fs;

    //Mit Autowired wird dieses Bean automatisch mit den anderen Beans vernetzt.

    //Nun wird FileSystem in Konstruktor übergeben, sodass FileSystem erst erzeugt werden muss, damit der
    //Konstruktor ausgeführt werden kann. Damit die Vernetzung funktioniert muss die Klasse FsCommands eine @Component
    //sein und FileSystem muss eine @Component sein.
    //1. FileSystem erzeugen, 2. An Konstruktor übergeben und ausführen:

    @Autowired
    public FsCommands(FileSystem fs) {
        this.fs = fs;
    }


//- Setter-Injection:
    private FileSystem fs;  // Unterschied zu Constructor Injection: Variable kann nicht final sein.

    @Autowired
    public void setFileSystem(FileSystem fs) {  // Im Prinzip wie beim Konstruktor.
        this.fs = fs;
    }


//- Field-Injection:
    @Autowired private FileSystem fs;  // Kann auch nicht final sein.

//Hier wird @Autowired direkt neben die Variable geschrieben, da wir uns etwas von der Objekt-Variable wünschen.



Was passiert während des Field-Injection im Hintergrund?
1. Container fährt hoch
2. Container erkennt Shell-Komponente und initialisiert sie
3. Container erkennt die Annotation @Autowired, hier will jemand etwas haben
4. Folglich nimmt er aus dem Kontext das Dateisystem FileSystem, welches logischerweise vorher aufgebaut sein muss,
und schreibt es per Reflection in diese private Variable rein.

Constructor- und Setter-Injection sind die bessere Variante. Sie eignen sich auch besser für Tests.
Constructor-Injection macht auch deutlich welche Referenzen hier benötigt werden. Bei den anderen sind die Referenzen
eher versteckt. (API Dokumentationen)
Zusätzlicher Vorteil des Constructor-Injection ist die finale Variable. Es können nachträglich keine Änderungen daran
vorgenommen werden.

Field Injections sind eine eher unsaubere Lösung, da hier über Reflections etwas getrickst werden muss.
Weitere Nachteile:
- Objektvariablen können nicht final sein
- Abhängigkeiten werden etwas versteckt (API Dokumentation zeigt die Abhängigkeiten fälschlicherweise nicht an)
    -> Bei Tests kann es dann zu Exceptions kommen (NullPointerException), da Abhängigkeiten fehlen.
- Bei Constructor und Setter kann Programmcode direkt starten, wenn der Container den Constructor/Setter aufruft.
Das ist bei Field-Injection nicht möglich. Die Variablen sind plötzlich da und initialisiert und Objekte lassen sich
nicht mehr umwandeln, anpassen.
- Im Testfall lassen sich private Objektvariablen nur über Reflection beschreiben.


