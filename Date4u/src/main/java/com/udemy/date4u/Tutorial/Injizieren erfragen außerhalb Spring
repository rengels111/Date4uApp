Injizierung in Spring unmanaged Beans
Damit das Injizieren der Abhängigkeiten funktioniert, muss Spring die Komponenten selbst aufgebaut haben.
Es gibt aber auch Stellen außerhalb von Spring, die ebenfalls Objekte aufbauen:
- Programme erzeugen mit new Objekte, etwa bei Ereignissen, die dann versendet werden.
- Objekte werden durch die Deserialisierung rekonstruiert. Das gilt oft für Behälter.
- Frameworks erstellen Objekte für uns: JavaFX erzeugt Controller-Instanzen, ein Jakarta Persistence Provider lädt und
instanziiert Entity-Beans und Entity-Listener, etc.
-> Spring kann auch für diese 'unmanaged'-Objekte eine Verdrahtung vornehmen.
    - Die Verdrahtung kann von außen oder von innen erfolgen.


1. Methode: AutowireCapableBeanFactory
Eine DefaultListableBeanFactory implementiert die Schnittstelle AutowireCapableBeanFactory.
Die autowire*(...)-Methoden führen auf einer nicht-Spring-managed Bean Verdrahtungen durch.
-> D.h. es ist möglich nicht-Beans nachträglich mit autowire-Methoden mit anderen Beans zu verdrahten, andere Beans
dort zu injizieren.

Beispiel mit einem @Service, der Währungen formatieren kann:

@Service
class CurrencyFormatter {
    public String format( double d ) {
        return d + " €";
    }
}

// Dies ist eine externe Klasse, die nicht zu Spring gehört und somit keine Bean Component ist:
class MonetaryAmount {
    private final double amount;

    @Autowired CurrencyFormatter currencyFormatter;  // wieso funktioniert das? Das sehen wir gleich im nächsten Schritt.

    public MonetaryAmount( double amount ) {
        this.amount = amount;
    }
    @Override public String toString() {
        return currencyFormatter.format( amount );
    }
}

// Hier erstellen wir jetzt eine Klasse, die das Autowire bei MonetaryAmount ermöglichen soll:
@Component
class MonetaryAmountFactory {
    @Autowired DefaultListableBeanFactory beanFactory;  // wir verdrahten die Schnittstelle, die entscheidend ist, um
    die autowire-Methode anzuwenden.

    // Diese Methode erstellt ein Objekt mit dem Parameter double amount:
    MonetaryAmount createAmount( double amount ) {
        MonetaryAmount monetaryAmount = new MonetaryAmount ( amount );

        beanFactory.autowireBean( monetaryAmount );  // -> hier wird die autowireBean Methode angewendet, damit die
        Komponente "monetaryAmount" automatisch autowired wird.

        return monetaryAmount;
    }
}
Damit ist MonetaryAmount zwar keine Spring-managed Bean, aber mit dieser Komponente wird monetaryAmount autowired.
Auf diese Weise werden alle autowires vorgenommen, daher bekommt MonetaryAmount auch den CurrencyFormatter.

Und so kann das Ganze nun eingesetzt werden:
@SpringBootApplication
public class AutowireBeanDemo {
    public static void main( String[] args ) {
        var ctx = SpringApplication.run( AutowireBeanDemo.class, args );  // Der Container wird gestartet
        var amountFactory = ctx.Bean( MonetaryAmountFactory.class );  // mit getBean holen wir die Bean raus
        System.out.println( amountFactory.createAmount( 12.3 ) );  // diese Bean hat die Methode createAmount.
        // Wenn diese Methode nun durchgeführt wird, dann wird intern das autowireBean durchgeführt.
        // Somit funktioniert dann auch die toString Methode mit dem CurrencyFormatter.
    }
}


2. Es gibt weitere Methoden, wie in nicht Spring managed Beans injiziert werden kann. Die schreibe ich jetzt nicht auf.
Das wird alles sehr komplex und ich weiß noch nicht ob ich das wirklich gebrauchen kann. (ab Kapitel 26, 6:48min)


Spring-managed Beans woanders anmelden, in anderen Frameworks.
- getBean(...)-Methoden und getBeansWithAnnotation(...). (Kapitel 26. 15:55 min)
...



