Abstraktionen und Qualifizierungen

Ein Bean kann gerufen werden, ohne dass man weiß was für ein Typ das ist, nämlich indem man den Namen der Bean zum
rufen verwendet.
Ohne explizite Benennung wird der Name automatisch festgelegt:
- kleingeschriebener @Component-Name
- Name der @Bean-Fabrikmethode


Wir können eine Schnittstelle mit einer Methode erstellen und diese in eine Klasse implementieren (wie wir es mit
Thumbnail gemacht haben). Die Methode wird dort überschrieben und dann haben wir sogar die Möglichkeit nur den Basistyp,
also in dem Fall nur diese Schnittstelle per @Autowired zu injizieren und müssen nicht die ganze Klasse injizieren, die
den gesamten Code enthält (wie bei PhotoService).


Das Spring Framework ist auch flexibel, um anhand des Typs zu unterscheiden was genau mit @Autowired gemeint ist.
Wir können auch generische Typen einsetzen, die besonders parametrisiert sind:

@Configuration
class SupplierConfiguration {
    @Bean Supplier<FileSystem> filesystem() {...}
}

@Component
class PhotoServiceSupplier implements Supplier<PhotoService> {
    @Override public PhotoService get() {...}
}

Injizierung:
@Autowired Supplier<FileSystem> fs;

Das zeigt uns, dass Spring Boot hier ganz genau hinschaut und genau weiß welchen Supplier mit welchem Typ es injizieren
muss.


Es kann vorkommen, dass Spring Boot nicht weiß welcher Bean verwendet werden soll, wenn die gleiche Schnittstelle
bei mehreren Beans verwendet wird, welche wir aufgerufen haben oder Beans einfach den gleichen Namen/Typ besitzen, den
wir aufgerufen haben.
Dazu gibt es nun folgende Lösungen:

1. @Autowired mit @Qualifier
Eine Lösung ist die Komponente zu benennen:
@Service( "quality" )
class AwtBicubicThumbnail implements Thumbnail { ... }

@Service( "fast" )
class AwtNearestNeighborThumbnail implements Thumbnail { ... }

Beim Injizieren kann mit der Annotation @Qualifier der Name der gewünschten Komponente angegeben werden:

@Autowired @Qualifier( "quality" )
public void setThumbnail(Thumbnail thumbnail) {
    this.thumbnail = thumbnail;
}

Die Annotation @Qualifier ist auch bei Parametervariablen gültig. Das gilt auch für @Bean-Spring managed Beans.

2. Eigene Annotationstypen
Alternativ können eigene Annotationstypen als Qualifizierer geschrieben werden.
Es gibt dazu zwei Optionen:
- Zwei individuelle Annotationstypen, etwa @ThumbnailRenderingFast und @ThumbnailRenderingQuality hinzufügen.
- Einen Annotationstyp mit Kriterium, etwa @ThumbnailRendering(FAST) und @ThumbnailRendering(QUALITY) hinzufügen.

Wie das funktioniert lasse ich erstmal aus (Kurs 22. Abstraktionen und Qualifizierungen Teil 2, 9:15min)

3. @Primary
Falls es mehrere Implementierungen eines Basistyps gibt, kann die Hauptimplementierung mit @Primary annotiert werden.

@Service
@Primary
class AwtBicubicThumbnail implements Thumbnail { ... }

@Service
class AwtNearestNeighborThumbnail implements Thumbnail { ... }

Damit ist das wieder in Ordnung:
@Autowired
public void setThumbnail(Thumbnail thumbnail) {
    this.thumbnail = thumbnail;
}

4. Alle Beans in einer Datenstruktur
Wir können aber auch einfach alle diese Beans des gleichen Typs in einer Liste, einem Set, Array etc. speichern:
@Service
class AwtBicubicThumbnail implements Thumbnail

@Service AwtNearestNeighborThumbnail implements Thumbnail

@Service
class Whatever {
    @Autowired
    // @Qualifier möglich
    List<Thumbnail> thumbnails;
    // oder Set<Thumbnail thumbnails;
    // oder Thumbnail[] thumbnails;
}


@Resource
Neben der Spring-Annotation @Autowired unterstützt Spring auch die Annotation @Resource zum Beziehen von benannten
Ressourcen.
- @Resource wertet den Namen einer Spring-managed Bean höher als den Typ.
- Gültig ist @Resource an Objektvariablen oder Settern (mit einem Parameter).

Beispiel:

@Component( "profile" )
class UnicornProfile { ...}

@Component ( "unicornProfile" )
class Profile { ... }

und dann die Injizierung:
@Component
public class ResourceApplication {
    @Resource ( name = "profile" )
    void setABC( Object profile ) { ... }  // in dem Fall wird der Name der Komponente "profile" genutzt
    // -> class UnicornProfile.

    @Resource (name = "profile" )  // genauso hier bei Field Injection -> Komponente "profile" -> class UnicornProfile.
    Object abc;

    @Resource  // wird der Name weggelassen, wird er automatisch aus dem Namen im Setter gezogen -> "profile".
    void setProfile( Object profile ) { ... }

    @Resource  // auch hier wird der Name aus dem Namen "profile" gezogen und die dazugehörige Komponente ausgewählt.
    Object profile;
}

Zusammenfassend lässt sich sagen, dass die Anwendung von @Resource das gleiche bewirkt wie @Autowired mit @Qualifier.



ObjectProvider
ObjectProvider hatten wir bei optionalen Komponenten kennengelernt. Der Typ wird ähnlich wie Optional verwendet.
ObjectProvider stellt eine Live Abfrage der Beans aus dem Kontext.

Ein ObjectProvider lässt sich ganz einfach per Autowired injizieren:
@Autowired
ObjectProvider<Thumbnail> maybeThumbnail;

// Alternativ kann der ObjectProvider aus einem Applikationskontext geholt werden:
ObjectProvider<Thumbnail> maybeThumbnail = ctx.getBeanProvider( Thumbnail.class );

// Später:

maybeThumbnail.getIfAvailable();  // die Methode gibt dann zurück: null oder Bean
// oder:
maybeThumbnail.getIfAvailable( NoopThumbnail::new );  // wenn kein Bean vorhanden ist, dann kann ich mir selber einen
// aussuchen.

Es gibt 3 Möglichkeiten bei getIfAvailable:
1. Bean wird gefunden und instanziiert
2. Bean wird nicht gefunden, ergibt null (Exception) oder mit Supplier gibt Rückgabe mit neuer Bean
3. Mehrere passende Beans werden gefunden und geben eine Exception

weitere Methoden von ObjectProvider:
- ifAvailable(dependencyConsumer: Consumer<T>): void <<default>>
- getIfUnique(): T
- getIfUnique(defaultSupplier: Supplier<T>): T <<default>>
- ifUnique(dependencyConsumer: Consumer<T>): void <<default>>
- iterator(): Iterator<T> <<default>>
- stream(): Stream<T> <<default>>
- orderedStream(): Stream<T> <<default>>


@Order / @AutoConfigurationOrder
Spring berücksichtigt bei gewissen Operationen die Priorität von Objekten.
- Damit lässt sich z.B. die Reihenfolge der Elemente in der @Autowired-Liste bestimmen:
    @Autowired List<Thumbnail> thumbnails

Es gibt die folgenden Annotationen, um die Priorität zu bestimmen:
- @Order (für reguläre Komponenten)
- @AutoConfigurationOrder (für Konfigurationsklassen)

Beispiel für Thumbnail-Komponenten:

@Component @Order( 178 )  // niedrigste Priorität
class AwtNearestNeighborThumbnail implements Thumbnail

@Component @Order ( 0 )  // höhere Priorität
class DefaultThumbnail implements Thumbnail

@Component @Order ( -155 )  // höchste Priorität
class AwtBicubicThumbnail implements Thumbnail

-> je niedriger die Zahl, umso höher die Priorität

Es gibt noch die Schnittstelle Ordered:
- Nachteil für @Order: Das Annotationsattribut für die Priorität ist bei @Order immer statisch.
- Spring wertet bei Komponenten eine Implementierung der Schnittstelle Ordered mit einer Methode int getOrder()
als Alternative zur Angabe @Order aus.
    - So lassen sich auch zur Laufzeit dynamisch Vorgänge ermitteln.
    - Mehr dazu im Video (Kurs 22. Abstraktionen und Qualifizierungen Teil 2, 30:37min)


Vererbung, Implementierung von Beans
Oberklassen können @Bean-Methode besitzen:

abstract class Thing {
    @Bean UUID uuid() {
        return UUID.randomUUID();  // Abstrakte Oberklasse besitzt Bean-Methode
    }
}

@Configuration class Profile extends Thing { ... }  // Unterklasse erbt die @Bean aus der Oberklasse.
Das ist problemlos möglich.

Das ist gleichbedeutend wie:
abstract class Thing { ... }

@Configuration class Profile {
    @Bean UUID uuid() {
        return UUID.randomUUID();
    }
}

-> Spring Boot ist es egal ob die @Bean-Methoden zur eigenen Klasse gehören oder ob sie geerbt sind.

WICHTIG: Die Oberklasse, von der Beans geerbt werden sollen, darf nicht selbst eine @Component oder @Configuration sein!
(Das würde im oberen Fall auch keinen Sinn machen, denn von abstrakten Klassen können keine Objekte erzeugt werden.)

Auch bei Schnittstellen gilt das Gleiche:

interface Thing {
    @Bean default UUID uuid() {
        return UUID.randomUUID();
    }
}

@Component class Profile implements Thing { ... }
// Auch in diesem Fall wird die @Bean-Methode uuid() von der Schnittstelle problemlos geerbt.

- @Component, @Repository, @Service und @Controller können ihre Eigenschaften nicht vererben!
Sie tragen keine @Inherited Annotation.

Auch @Autoried in der Oberklasse kann an die Unterklasse vererbt werden:

abstract class Thing {
    @Autowired ApplicationContext ctx;
    @Autowired void setArgs( ApplicationArguments args ) { ... }
}

@Component
class Profile extends Thing { ... }
// -> hier werden die @Autowired Objektvariablen und Methoden an Profile vererbt.

Wichtig zu beachten:
- Wenn die @Autowired Methode aus der Oberklasse in der Unterklasse überschrieben wird, dann wird das Autowired nicht
mehr funktionieren. Daher ist es beim Überschreiben der @Autowired Methode wichtig, dass @Autowired in der Unterklasse
ebenfalls gesetzt wird.

